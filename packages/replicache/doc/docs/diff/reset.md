---
title: The Reset Strategy
slug: /concepts/diff/reset
---

# ðŸ¤ª The Reset Strategy

The Reset Strategy is the easiest possible backend strategy: it sends the entire client view on every pull response, so no patch calculation is necessary at all.

Sending the entire client view this way is extremely inefficient, and therefore this approach is not recommended for anything but early development or the tinyiest production applications.

It's still useful for learning Replicache, or for a starting point to understand other strategies.

## How it Works

### Schema

Besides your own domain data, your backend database will need to store one additional entity:

```yaml
# An instance of the Replicache JS class that has synced with the server.
ReplicacheClient
  # Unique ID for client, generated by Replicache.
  id: string
  # Last mutation processed from this client.
  lastMutationID: uint
```

### Push

In an exclusive (serializable) database transaction:

<ol>
    <li>Read the <code>lastMutationID</code> for the calling client. If no such client exists, create one and default its <code>lastMutationID</code> to zero.</li>
    <li>Iterate through the pushed mutations. For each one:
        <ol>
            <li>Validate the mutation ID:
                <ol>
                    <li>If the mutation ID is smaller than the next expected mutation ID, this mutation has been processed. Skip it.</li>
                    <li>If the mutation ID is greater than the next expected mutation ID, there has been a critical error on either the client or server. This client can no longer sync. Log an error, abort transaction, exit push, and return HTTP 400 to client.</li>
                </ol>
            </li>
            <li>Process the mutation. Make whatever changes necessary to the backend database.</li>
            <li>Update the <code>lastMutationID</code> for the calling client.</li>
        </ol>
    </li>
    <li>Commit the transaction.</li>
</ol>

:::caution

It is important that the push happen in a serialized transaction, and that the `lastMutationID` is updated atomically as part of this transaction. If this requirement is violated, clients will end up in any incorrect state.

:::

### On Pull

In an exclusive (serializable) database transaction:

<ol>
    <li>Read the <code>lastMutationID</code> for the calling client, or default to zero if no such client exists.</li>
    <li>Read all entities needed for the requesting client's Client View from the database. This can be any arbitrary query of the database, including auth, filters, etc.</li>
    <li>Return <code>PullResponse</code> to the client:
        <ul>
            <li><code>lastMutationID</code>: lastMutationID for requesting client, or zero.</li>
            <li><code>cookie</code>: <code>null</code> (cookie not used by this strategy).</li>
            <li><code>patch</code>: Send a <em>reset patch</em>: a <code>clear</code> op followed by <code>put</code> ops for each entity in the client view.</li>
        </ul>
    </li>
</ol>

## Challenges

Needless to say this isn't a practical strategy for almost any real application. It's presented here mainly for educational reasons.

## Examples

The Get Started Guide [starts out with the Reset Strategy](/byob/client-view#serving-the-client-view) (using static data) before implementing dynamic pull.
